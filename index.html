<!DOCTYPE html>
<html>

<head>
  <style>
    body,
    html {
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    .map-container {
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      position: relative;
      user-select: none;
      background: black;
      touch-action: none;
    }

    .transform-accelerated {
      transform: translateZ(0);
      backface-visibility: hidden;
      perspective: 1000px;
    }

    .map-image {
      position: absolute;
      cursor: grab;
      will-change: transform;
      transform-origin: 0 0;
      opacity: 1;
    }

    .map-image.next {
      opacity: 0;
      transition: opacity 0.5s ease;
    }

    .resource-node {
      position: absolute;
      width: 12px;
      height: 12px;
      background-color: red;
      border-radius: 50%;
      pointer-events: auto;
      z-index: 1001;
      cursor: pointer;
    }

    .resource-node.fade-out {
      opacity: 0;
      transition: opacity 0.5s ease;
    }

    .tooltip {
      position: absolute;
      display: none;
      background: rgba(0, 0, 0, 0.7);
      color: #fff;
      padding: 5px;
      border-radius: 3px;
      pointer-events: none;
      font-family: sans-serif;
      font-size: 12px;
      z-index: 1002;
      white-space: pre-line;
    }

    .watermark {
      position: absolute;
      bottom: 10px;
      right: 10px;
      color: rgba(255, 255, 255, 0.5);
      font-family: Arial, sans-serif;
      font-size: 14px;
      z-index: 1000;
      pointer-events: none;
    }

    .mobile-toggle-text {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.7);
      font-family: Arial, sans-serif;
      font-size: 16px;
      z-index: 1000;
      pointer-events: auto;
      display: none;
      cursor: pointer;
    }

    @media (hover: none) and (pointer: coarse) {
      .mobile-toggle-text {
        display: block;
      }
    }
  </style>
</head>

<body>
  <div class="map-container" id="mapContainer">
    <img src="blank.png" class="map-image transform-accelerated" id="mapImage">
    <div class="watermark">made by bunnysquared.</div>
    <div id="tooltip" class="tooltip"></div>
    <div id="mobileToggleText" class="mobile-toggle-text">Tap here to toggle resources</div>
  </div>

  <script>
    let isDragging = false;
    let translateX = 0;
    let translateY = 0;
    let scale = 1;
    let initialScale = 1;
    let startX = 0;
    let startY = 0;
    const maxScale = 10;
    let zoomAnimationId = null;
    let initialDistance = null;
    let initialScalePinch = 1;
    let initialTouchCenter = { x: 0, y: 0 };

    const maps = [
      "blank.png",
      "country.png",
      "religion.png"
    ];
    let currentMapIndex = 0;

    const resourceNodesData = [
      { x: 400, y: 600, type: 'Oil', country: 'Property of A', reserves: '500 million barrels' },
      { x: 800, y: 300, type: 'Natural gas', country: 'Property of B', reserves: '300 millions of m³' },
      { x: 1200, y: 900, type: 'Minerals', country: 'Property of C', reserves: '1.2 million tons' }
    ];
    let resourceNodesElements = [];

    function getDimensions() {
      return {
        container: { 
          w: mapContainer.clientWidth, 
          h: mapContainer.clientHeight 
        },
        image: { 
          w: mapImage.naturalWidth, 
          h: mapImage.naturalHeight 
        }
      };
    }

    function applyConstraints() {
      const { container, image } = getDimensions();
      const scaledWidth = image.w * scale;
      const scaledHeight = image.h * scale;

      translateX = scaledWidth < container.w ?
        (container.w - scaledWidth) / 2 :
        Math.min(Math.max(translateX, container.w - scaledWidth), 0);

      translateY = scaledHeight < container.h ?
        (container.h - scaledHeight) / 2 :
        Math.min(Math.max(translateY, container.h - scaledHeight), 0);
    }

    function updateMapTransform() {
      mapImage.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
      if (resourceNodesElements.length > 0) {
        updateResourceNodesPositions();
      }
    }

    function updateResourceNodesPositions() {
      const nodeSize = 12;
      resourceNodesElements.forEach(item => {
        const { x, y } = item.data;
        const left = x * scale + translateX - nodeSize / 2;
        const top = y * scale + translateY - nodeSize / 2;
        item.element.style.transform = `translate(${left}px, ${top}px)`;
      });
    }

    function showResourceNodes() {
      if (resourceNodesElements.length > 0) return;
      
      resourceNodesData.forEach(data => {
        const node = document.createElement('div');
        node.className = 'resource-node transform-accelerated';
        
        node.addEventListener('dblclick', () => zoomToNode(data.x, data.y));
        node.addEventListener('touchstart', (e) => {
          e.preventDefault();
          if (isMobile()) showNodeInfo(node, data);
        });

        node.addEventListener('mouseenter', () => {
          tooltip.textContent = `${data.type}\nCountry: ${data.country}\nReserves: ${data.reserves}`;
          tooltip.style.display = 'block';
        });
        
        node.addEventListener('mousemove', (e) => {
          tooltip.style.left = `${e.pageX + 10}px`;
          tooltip.style.top = `${e.pageY + 10}px`;
        });
        
        node.addEventListener('mouseleave', () => {
          tooltip.style.display = 'none';
        });

        mapContainer.appendChild(node);
        resourceNodesElements.push({ element: node, data });
      });
      updateResourceNodesPositions();
    }

    function hideResourceNodes() {
      resourceNodesElements.forEach(item => {
        item.element.remove();
      });
      resourceNodesElements = [];
      tooltip.style.display = 'none';
    }

    function zoomToNode(x, y) {
      if (zoomAnimationId) cancelAnimationFrame(zoomAnimationId);

      const { container } = getDimensions();
      const targetScale = Math.min(scale * 2, maxScale);
      if (targetScale === scale) return;

      const nodeX = x * scale + translateX;
      const nodeY = y * scale + translateY;
      const targetTranslateX = (container.w / 2) - (x * targetScale);
      const targetTranslateY = (container.h / 2) - (y * targetScale);

      const startTime = performance.now();
      
      const animateZoom = (currentTime) => {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / 300, 1);

        scale = scale + (targetScale - scale) * progress;
        translateX = translateX + (targetTranslateX - translateX) * progress;
        translateY = translateY + (targetTranslateY - translateY) * progress;
        
        applyConstraints();
        updateMapTransform();

        if (progress < 1) {
          zoomAnimationId = requestAnimationFrame(animateZoom);
        } else {
          zoomAnimationId = null;
        }
      };

      zoomAnimationId = requestAnimationFrame(animateZoom);
    }

    // Event handlers restaurados
    function handleTouch(e) {
      if (e.touches.length === 1) {
        isDragging = true;
        startX = e.touches[0].clientX - translateX;
        startY = e.touches[0].clientY - translateY;
      } else if (e.touches.length === 2) {
        e.preventDefault();
        initialDistance = getTouchDistance(e.touches[0], e.touches[1]);
        initialScalePinch = scale;
        initialTouchCenter = getTouchCenter(e.touches[0], e.touches[1]);
      }
    }

    function handleTouchMove(e) {
      if (e.touches.length === 1 && isDragging) {
        e.preventDefault();
        translateX = e.touches[0].clientX - startX;
        translateY = e.touches[0].clientY - startY;
        applyConstraints();
        updateMapTransform();
      } else if (e.touches.length === 2) {
        e.preventDefault();
        const currentDistance = getTouchDistance(e.touches[0], e.touches[1]);
        if (initialDistance) {
          scale = Math.min(maxScale, Math.max(initialScale, (currentDistance / initialDistance) * initialScalePinch));
          applyConstraints();
          updateMapTransform();
        }
      }
    }

    // Inicialización y event listeners
    function initialize() {
      // Eventos de mouse
      mapContainer.addEventListener('mousedown', startDragging);
      document.addEventListener('mouseup', stopDragging);
      document.addEventListener('mousemove', drag);

      // Eventos táctiles
      mapContainer.addEventListener('touchstart', handleTouch);
      mapContainer.addEventListener('touchmove', handleTouchMove);
      mapContainer.addEventListener('touchend', () => {
        isDragging = false;
        initialDistance = null;
      });

      document.addEventListener('keydown', (e) => {
        const key = e.key.toLowerCase();
        if (['1','2','3'].includes(e.key)) changeMap(parseInt(e.key)-1);
        if (key === 'r') resourceNodesElements.length ? hideResourceNodes() : showResourceNodes();
        if (key === 'm') mobileToggleText.style.display = 
          mobileToggleText.style.display === 'none' ? 'block' : 'none';
      });

      mapContainer.addEventListener('touchstart', (e) => {
        if (e.touches.length !== 1) return;
        const touchX = e.touches[0].clientX;
        const edgeThreshold = 50;
        
        if (touchX < edgeThreshold) {
          changeMap((currentMapIndex - 1 + maps.length) % maps.length);
        } else if (touchX > window.innerWidth - edgeThreshold) {
          changeMap((currentMapIndex + 1) % maps.length);
        }
      });

      mobileToggleText.addEventListener('click', () => {
        resourceNodesElements.length ? hideResourceNodes() : showResourceNodes();
      });
    }

    function changeMap(newIndex) {
      const oldMap = mapImage;
      const newMap = new Image();
      newMap.className = 'map-image transform-accelerated next';
      newMap.src = maps[newIndex];

      newMap.onload = () => {
        scale = Math.min(
          mapContainer.clientWidth / newMap.naturalWidth,
          mapContainer.clientHeight / newMap.naturalHeight
        );
        translateX = (mapContainer.clientWidth - newMap.naturalWidth * scale) / 2;
        translateY = (mapContainer.clientHeight - newMap.naturalHeight * scale) / 2;
        
        mapContainer.appendChild(newMap);
        oldMap.style.opacity = 0;
        newMap.style.opacity = 1;

        setTimeout(() => {
          oldMap.remove();
          mapImage = newMap;
          currentMapIndex = newIndex;
          hideResourceNodes();
          updateMapTransform();
        }, 500);
      };
    }

    function startDragging(e) {
      e.preventDefault();
      isDragging = true;
      startX = e.clientX - translateX;
      startY = e.clientY - translateY;
      mapImage.style.cursor = 'grabbing';
    }

    function drag(e) {
      if (!isDragging) return;
      e.preventDefault();
      
      translateX = e.clientX - startX;
      translateY = e.clientY - startY;
      applyConstraints();
      updateMapTransform();
    }

    function stopDragging() {
      isDragging = false;
      mapImage.style.cursor = 'grab';
    }

    function getTouchDistance(t1, t2) {
      return Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
    }

    function getTouchCenter(t1, t2) {
      return {
        x: (t1.clientX + t2.clientX) / 2,
        y: (t1.clientY + t2.clientY) / 2
      };
    }

    function isMobile() {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }

    mapImage.onload = () => {
      initialScale = Math.min(
        mapContainer.clientWidth / mapImage.naturalWidth,
        mapContainer.clientHeight / mapImage.naturalHeight
      );
      setInitialZoom();
      initialize();
    };

    function setInitialZoom() {
      const { container, image } = getDimensions();
      scale = Math.min(container.w / image.w, container.h / image.h);
      translateX = (container.w - image.w * scale) / 2;
      translateY = (container.h - image.h * scale) / 2;
      updateMapTransform();
    }
  </script>
</body>

</html>
